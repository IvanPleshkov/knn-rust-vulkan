#version 450

#include "base.comp"

#define LARGE_K

layout(binding = 0) uniform KnnUniformBuffer {
    uint dim;
    uint capacity;
    uint block_size;
    uint k;
} knn;

layout(binding = 1) buffer VectorData {
    vec4 data[];
} vectors;

layout(binding = 2) buffer QueryData {
    vec4 data[];
} query;

layout(binding = 3) buffer ScoresData {
    ScoredPoint data[];
} scores;

#ifdef LARGE_K
#define BHEAP_DATA scores.data
#else
ScoredPoint heap_data[8];
#define BHEAP_DATA heap_data
#endif
#define BHEAP_NAME bheap
#define BHEAP_TYPE ScoredPoint
#define BHEAP_CMP(a, b) a.score > b.score
#include "bheap.comp"

void main() {
#ifdef LARGE_K
    uint offset = gl_GlobalInvocationID.x * knn.k;
#else
    uint offset = 0;
#endif
    BHEAP(bheap, init)(ScoredPoint(0, positive_infinity), knn.k, offset);
 
    uint d = knn.dim / 4;
    for (uint relativePointId = 0; relativePointId < knn.block_size; relativePointId++) {
        uint pointId = gl_GlobalInvocationID.x * knn.block_size + relativePointId;
        float score = 0.0;
        for (uint i = 0; i < d; i++) {
            score += dot(vectors.data[pointId * d + i], query.data[i]);
        }
        // check if not nan
        if (score < 0.0 || 0.0 < score || score == 0.0) {
            if (BHEAP(bheap, size) == BHEAP(bheap, capacity)) {
                if (score < BHEAP(bheap, top)().score) {
                    BHEAP(bheap, change_top)(ScoredPoint(pointId, score));
                }
            } else {
                BHEAP(bheap, push)(ScoredPoint(pointId, score));
            }
        }
    }

#ifndef LARGE_K
    for (uint i = 0; i < knn.k; i++) {
        scores.data[gl_GlobalInvocationID.x * knn.k + i] = heap_data[i];
    }
#endif
}
