#version 450

#include "base.comp"

layout(set = 0, binding = 0)
uniform LevelSearcherUniformBuffer {
    uint entry_point;
    uint ef;
    uint candidates_capacity;
    uint dim;
    uint count;
    uint inserting_point_id;
} params;

layout(set = 0, binding = 1)
readonly buffer Vectors {
    vec4 data[];
} vectors;

layout(set = 0, binding = 2)
readonly buffer Links {
    uint data[];
} links;

layout(set = 0, binding = 3)
buffer VisitedFlags {
    uint data[];
} visited_flags;

layout(set = 0, binding = 4)
buffer Nearest {
    ScoredPoint data[];
} nearest;

layout(set = 0, binding = 5)
buffer Candidates {
    ScoredPoint data[];
} candidates;

// nearest binary heap
#define BHEAP_NAME nearest
#define BHEAP_DATA nearest.data
#define BHEAP_TYPE ScoredPoint
#define BHEAP_CMP(a, b) a.score < b.score
#include "bheap.comp"

// candidates binary heap
#define BHEAP_NAME candidates
#define BHEAP_DATA candidates.data
#define BHEAP_TYPE ScoredPoint
#define BHEAP_CMP(a, b) a.score > b.score
#include "bheap.comp"

bool check_and_process_visited(uint id) {
    uint flag_index = gl_GlobalInvocationID.x * params.count + id / 32;
    uint flag_bit = id % 32;
    uint flag = visited_flags.data[flag_index];
    uint flag_mask = 1 << flag_bit;
    bool unvisited = (flag & flag_mask) == 0;
    visited_flags.data[flag_index] = flag | flag_mask;
    return unvisited;
}

void get_links(uint point_id, out uint begin_index, out uint end_index) {
    begin_index = links.data[2 * point_id + 0];
    end_index = links.data[2 * point_id + 1];
}

float score_point(uint point_id1, uint point_id2) {
    uint d = params.dim >> 2;
    float score = 0.0;
    for (uint i = 0; i < d; i++) {
        score += dot(vectors.data[point_id1 * d + i], vectors.data[point_id2 * d + i]);
    }
    return score;
}

void main() {
    BHEAP(nearest, init)(
        ScoredPoint(0, negative_infinity),
        params.ef,
        gl_GlobalInvocationID.x * params.ef);
    BHEAP(candidates, init)(
        ScoredPoint(0, positive_infinity),
        candidates_capacity,
        gl_GlobalInvocationID.x * candidates_capacity);

    check_and_process_visited(params.entry_point);
    ScoredPoint entry_scored_point = ScoredPoint(
        params.entry_point,
        score_point(params.entry_point, params.inserting_point_id));
    BHEAP(nearest, push)(entry_scored_point);
    BHEAP(candidates, push)(entry_scored_point);

    while (BHEAP(candidates, size) > 0) {
        ScoredPoint candidate = BHEAP(candidates, pop)();
        if (candidate.score < BHEAP(nearest, top)().score) {
            break;
        }
        
        uint links_begin;
        uint links_end;
        get_links(candidate.id, links_begin, links_end);

        for (uint i = links_begin; i < links_end; i++) {
            uint point_id = links.data[i];
            if (check_and_process_visited(point_id)) {
                ScoredPoint scored_point = ScoredPoint(
                    point_id,
                    score_point(point_id, params.inserting_point_id));
                if (BHEAP(nearest, size) == BHEAP(nearest, capacity)) {
                    if (scored_point.score > BHEAP(nearest, top)().score) {
                        BHEAP(nearest, change_top)(scored_point);
                        BHEAP(candidates, push)(scored_point);
                    }
                } else {
                    BHEAP(nearest, push)(scored_point);
                    BHEAP(candidates, push)(scored_point);
                }
            }
        }
    }
}
