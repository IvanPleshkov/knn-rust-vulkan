#version 450

#define LARGE_K

struct Score {
    uint idx;
    float score;
};

layout(binding = 0) uniform KnnUniformBuffer {
    uint dim;
    uint capacity;
    uint block_size;
    uint k;
} knn;

layout(binding = 1) buffer ScoresSrc {
    Score data[];
} scoresSrc;

layout(binding = 2) buffer ScoresDst {
    Score data[];
} scoresDst;

#ifdef LARGE_K

#define BHEAP_NAME LargeHeap
#define BHEAP_DATA scoresDst.data
#define BHEAP_TYPE Score
#define BHEAP_CMP(a, b) a.score > b.score
#include "bheap.comp"

#else

Score heap_data[8];

#define BHEAP_NAME SmallHeap
#define BHEAP_DATA heap_data
#define BHEAP_TYPE Score
#define BHEAP_CMP(a, b) a.score > b.score
#include "bheap.comp"

#endif

void main()
{
    bheap_capacity = knn.k;
#ifdef LARGE_K
    bheap_offset = gl_GlobalInvocationID.x * knn.k;
#else
    bheap_offset = 0;
#endif

    for (uint relativePointId = 0; relativePointId < knn.block_size - 1; relativePointId++) {
        uint pointId = gl_GlobalInvocationID.x * knn.block_size + relativePointId;
        Score score = scoresSrc.data[pointId];
        if (bheap_size == bheap_capacity - 1) {
            if (score.score < bheap_top().score) {
                bheap_push(score);
                bheap_pop();
            }
        } else {
            bheap_push(score);
        }
    }
    uint pointId = gl_GlobalInvocationID.x * knn.block_size + knn.block_size - 1;
    bheap_push(scoresSrc.data[pointId]);

#ifndef LARGE_K
    for (uint i = 0; i < knn.k; i++) {
        scoresDst.data[gl_GlobalInvocationID.x * knn.k + i] = bheap_pop();
    }
#endif
}
